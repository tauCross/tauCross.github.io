---
layout: post
title:  "GCD官方文档解析"
date:  2017-04-28 10:09:30 +0800
categories: GCD iOS
---



# 官方文档

点击前往<a href="https://developer.apple.com/reference/dispatch" target="_blank">官方文档</a>。

# Dispatch

多核硬件上可以让代码同时提交运行在Dispatch队列中的系统。可以理解为Dispatch队列封装了底层多核系统调度的操作，我们只需要关心对Dispatch队列的操作，不需要关心任务到底分配给哪个核心，也不需要关心任务在哪个线程执行。

![](/Resource/GCD.png)

官方文档介绍GCD反正就是很牛逼，鹅妹子嘤，在保证稳定性的前提下各种利用多核系统的CPU资源同时处理各种事务。

**注意**

如果用OC开发App的话所有的dispatch对象会被当成OC对象来管理，所以在ARC下面不需要关心内存引用计数的问题，而在MRC下则需要利用`dispatch_retain`与`dispatch_release`手动管理。

 ```objective-c
dispatch_queue_t queue = dispatch_queue_create("com.tc.demo", DISPATCH_QUEUE_SERIAL);
...
dispatch_retain(queue);
...
dispatch_release(queue);
...
dispatch_release(queue);
 ```

## 队列管理

### Dispatch Queue Types

##### 创建队列

```objective-c
dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr);
```

参数：

* `const char *label`

  给队列一个标签，方便调试时区分队列，一般以反向DNS风格命名，如`"com.tc.queue"`，该参数可以为空（`NULL`）。

* `dispatch_queue_attr_t attr`

  这个属性指定队列类型`DISPATCH_QUEUE_SERIAL`为串行队列，`DISPATCH_QUEUE_CONCURRENT`为并行队列，该参数可为空（`NULL`），当该参数为空时，默认为串行队列，在iOS 4.3或更早版本上，只能指定该参数为空。

##### 队列类型

* 串行队列

  `DISPATCH_QUEUE_SERIAL`

  按先进先出的顺序处理传入的block。

  ```objective-c
  - (void)test
  {
      __block int index = 1;
      dispatch_queue_t queue_serial = dispatch_queue_create("com.tc.serial", DISPATCH_QUEUE_SERIAL);
      NSLog(@"开始运行");
      dispatch_async(queue_serial, ^{
          sleep(3);
          NSLog(@"第1个进入的Block, 第%i个出队列", index++);
      });
      dispatch_async(queue_serial, ^{
          NSLog(@"第2个进入的Block, 第%i个出队列", index++);
      });
      dispatch_async(queue_serial, ^{
          sleep(5);
          NSLog(@"第3个进入的Block, 第%i个出队列", index++);
      });
      dispatch_async(queue_serial, ^{
          sleep(1);
          NSLog(@"第4个进入的Block, 第%i个出队列", index++);
      });
  }
  ```

  输出（请注意时间）：

  ```
  2017-04-28 18:18:47.732 demo[36802:2352075] 开始运行
  2017-04-28 18:18:50.736 demo[36802:2352122] 第1个进入的Block, 第1个出队列
  2017-04-28 18:18:50.737 demo[36802:2352122] 第2个进入的Block, 第2个出队列
  2017-04-28 18:18:55.740 demo[36802:2352122] 第3个进入的Block, 第3个出队列
  2017-04-28 18:18:56.744 demo[36802:2352122] 第4个进入的Block, 第4个出队列
  ```

* 并行队列

  `DISPATCH_QUEUE_CONCURRENT`

  传入的block被并发的处理，先传入的block不一定比后传入的block先完成，取决于之前block的处理时间，文档上还说虽然是并发处理的，但可以使用barrier block在并行队列中设置同步点，关于barrier block会在后面讲到。

  ```objective-c
  - (void)test
  {
      __block int index = 1;
      dispatch_queue_t queue_concurrent = dispatch_queue_create("com.tc.concurrent", DISPATCH_QUEUE_CONCURRENT);
      NSLog(@"开始运行");
      dispatch_async(queue_concurrent, ^{
          sleep(3);
          NSLog(@"第1个进入的Block, 第%i个出队列", index++);
      });
      dispatch_async(queue_concurrent, ^{
          NSLog(@"第2个进入的Block, 第%i个出队列", index++);
      });
      dispatch_async(queue_concurrent, ^{
          sleep(5);
          NSLog(@"第3个进入的Block, 第%i个出队列", index++);
      });
      dispatch_async(queue_concurrent, ^{
          sleep(1);
          NSLog(@"第4个进入的Block, 第%i个出队列", index++);
      });
  }
  ```

  输出（请注意时间）：

  ```
  2017-04-28 18:28:25.394 demo[36859:2359335] 开始运行
  2017-04-28 18:28:25.394 demo[36859:2359507] 第2个进入的Block, 第1个出队列
  2017-04-28 18:28:26.395 demo[36859:2359505] 第4个进入的Block, 第2个出队列
  2017-04-28 18:28:28.395 demo[36859:2359522] 第1个进入的Block, 第3个出队列
  2017-04-28 18:28:30.395 demo[36859:2359504] 第3个进入的Block, 第4个出队列
  ```

### Dispatch Queue Label Constants

##### 获取队列Label

```
const char * dispatch_queue_get_label(dispatch_queue_t queue);
```

参数：

* `dispatch_queue_t queue`

  需要获取Label的队列。

  如果需要获取当前队列的Label则使用`DISPATCH_CURRENT_QUEUE_LABEL`。

```
- (void)test
{
    dispatch_queue_t queue = dispatch_queue_create("com.tc.queue1", NULL);
    dispatch_sync(queue, ^{
        NSLog(@"%s", dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL));
    });
    NSLog(@"%s", dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL));
    NSLog(@"%s", dispatch_queue_get_label(queue));
}
```

输出：

```
2017-05-02 11:16:57.771 demo[38100:2468155] com.tc.queue1
2017-05-02 11:16:57.771 demo[38100:2468155] com.apple.main-thread
2017-05-02 11:16:57.771 demo[38100:2468155] com.tc.queue1
```

### dispatch_queue_t

##### 队列

```dui
typedef NSObject<OS_dispatch_queue> *dispatch_queue_t;
```

可见`dispatch_queue_t`其实是个对象，也很好的解释了在MRC下为何要手动管理`dispatch_queue_t`的内存。

Dispatch队列其实都是FIFO的，在串行队列上毋庸置疑。在并行队列上从表面上看并不符合FIFO的原则，但其实并行队列应该理解为n个并行的队列组合，组合中每个队列也是符合FIFO原则的，GCD帮助程序员管理了如何分配任务给这些组合里的队列。

### dispatch_get_main_queue

##### 获取主队列

```
dispatch_queue_t dispatch_get_main_queue(void);
```

这个函数返回程序的主队列，这个队列在程序一开始时就被创建并与主线程关联，主队列是串行队列。

**注意：主线程与主队列并不等同**

主队列在在主线程被创建并关联的时机：

1. 调用`dispatch_main()`
2. 调用`UIApplicationMain`（iOS）或者`NSApplicationMain`（macOS）
3. 在主线程使用`CFRunLoopRef`

大多数情况下我们的App会在`mian()`函数里使用第2种方式。

对主队列使用`dispatch_suspend`、`dispatch_resume`、`dispatch_set_context`是无效的。

```
- (void)test
{
    __block int index = 1;
    dispatch_queue_t queue_main = dispatch_get_main_queue();
    NSLog(@"开始运行");
    dispatch_async(queue_main, ^{
        sleep(3);
        NSLog(@"第1个进入的Block, 第%i个出队列", index++);
    });
    dispatch_async(queue_main, ^{
        NSLog(@"第2个进入的Block, 第%i个出队列", index++);
    });
    dispatch_async(queue_main, ^{
        sleep(5);
        NSLog(@"第3个进入的Block, 第%i个出队列", index++);
    });
    dispatch_async(queue_main, ^{
        sleep(1);
        NSLog(@"第4个进入的Block, 第%i个出队列", index++);
    });
    dispatch_suspend(queue_main);
}
```

输出：

```
2017-05-02 16:57:01.814 demo[39074:2669261] 开始运行
2017-05-02 16:57:04.824 demo[39074:2669261] 第1个进入的Block, 第1个出队列
2017-05-02 16:57:04.824 demo[39074:2669261] 第2个进入的Block, 第2个出队列
2017-05-02 16:57:09.824 demo[39074:2669261] 第3个进入的Block, 第3个出队列
2017-05-02 16:57:10.826 demo[39074:2669261] 第4个进入的Block, 第4个出队列
```



### dispatch_get_global_queue

##### 获取全局并行队列

```
dispatch_queue_t dispatch_get_global_queue(long identifier, unsigned long flags);
```

返回系统预定义的全局并行队列。

参数：

* `long identifier`

  全局队列的ID，区别就在于优先级。

  iOS8.0或以上版本：

  * QOS_CLASS_USER_INTERACTIVE
  * QOS_CLASS_USER_INITIATED
  * QOS_CLASS_DEFAULT
  * QOS_CLASS_UTILITY
  * QOS_CLASS_BACKGROUND
  * QOS_CLASS_UNSPECIFIED

  iOS8以下的版本：

  * DISPATCH_QUEUE_PRIORITY_HIGH
  * DISPATCH_QUEUE_PRIORITY_DEFAULT
  * DISPATCH_QUEUE_PRIORITY_LOW
  * DISPATCH_QUEUE_PRIORITY_BACKGROUND

  tips：在background队列中，对I/O操作进行了优化，具体可参考<a href="http://www.cocoachina.com/ios/20170105/18525.html" target="_blank">iOS编程中throttle那些事</a>。

* `unsigned long flags`

  为未来的API预留的参数，现在不用管，直接传0。

对系统预定义队列使用`dispatch_suspend`、`dispatch_resume`、`dispatch_set_context`是无效的。

### dispatch_set_target_queue

