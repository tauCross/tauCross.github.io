<!DOCTYPE html>
<html>    
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width initial-scale=1">

  <title>GCD官方文档解析 - Managing Dispatch Queues</title>
  <meta name="description" content="上一篇文章简单介绍了下GCD，这里给大家讲解GCD中关于队列管理的一些知识，也是GCD最常用的部分。">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://localhost:4000/gcd/ios/2017/06/07/GCD%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E8%A7%A3%E6%9E%90-Managing-Dispatch-Queues.html">
  <link rel="alternate" type="application/atom+xml" title="tauCross's Blog" href="http://localhost:4000/feed.xml" />
  <script src="/scripts/jquery-1.11.2.min.js"></script>
  <script src="/scripts/pithy.js"></script>
</head>


  <body>
    <header class="header">
	<div class="header-container">
		<div class="nav">
			
				<li>
					<a href="/index.html">首页</a>
				</li>
			
			
				<li>
					<a href="/archive.html">文章列表</a>
				</li>
			
			
				<li>
					<a href="/category.html">分类</a>
				</li>
			
			<!-- 
				<li>
					<a href="/about.html">about</a>
				</li>
			 -->
		</div>
		<div class="description"> 都别抢！那是我的锅！ </div>
		<ul class="social-links">
			<li>
				<a href="https://github.com/tauCross" title="Github" target="_blank">
					<img width="19px" height="19px" src="/images/github.png"/>
				</a>
			</li>
			<li>
				<a href="https://www.zhihu.com/people/taucross" title="知乎" target="_blank">
					<img width="19px" height="19px" src="/images/zhihu.png"/>
				</a>
			</li>
		</ul>
	</div>
</header>

    <br>
    <div class="page-content">
      <div class="wrapper">
        <link rel="stylesheet" href="/css/github-markdown.css">

<style>
.supportFont{font-size:17px}
</style>



<div class="post">
  <br>
  <header class="post-header">
    <h1 class="post-title">GCD官方文档解析 - Managing Dispatch Queues</h1>
    <p class="post-meta">Jun 7, 2017 17:46:00</p>
  </header>

  <!-- <article class="markdown-body"> -->
    <article class="markdown-body">
      <p>上一篇文章简单介绍了下GCD，这里给大家讲解GCD中关于队列管理的一些知识，也是GCD最常用的部分。</p>

<h1 id="managing-dispatch-queues">Managing Dispatch Queues</h1>

<h2 id="dispatch-queue-types">Dispatch Queue Types</h2>

<h3 id="队列的类型">队列的类型</h3>

<ul>
  <li>
    <p>串行队列</p>

    <p><code class="highlighter-rouge">DISPATCH_QUEUE_SERIAL</code></p>

    <p>按先进先出的顺序处理传入的block。</p>
  </li>
  <li>
    <p>并行队列</p>

    <p><code class="highlighter-rouge">DISPATCH_QUEUE_CONCURRENT</code></p>

    <p>传入的block被并发的处理，先传入的block不一定比后传入的block先完成，取决于之前block的处理时间，文档上还说虽然是并发处理的，但可以使用barrier block在并行队列中设置同步点，关于barrier block会在后面讲到。</p>
  </li>
</ul>

<h3 id="创建队列">创建队列</h3>

<pre><code class="language-objective-c">dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr);
</code></pre>

<h4 id="参数">参数：</h4>

<ul>
  <li>
    <p><code class="highlighter-rouge">const char *label</code></p>

    <p>给队列一个标签，方便调试时区分队列，一般以反向DNS风格命名，如<code class="highlighter-rouge">"com.tc.queue"</code>，该参数可以为空（<code class="highlighter-rouge">NULL</code>）。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">dispatch_queue_attr_t attr</code></p>

    <p>这个属性指定队列类型<code class="highlighter-rouge">DISPATCH_QUEUE_SERIAL</code>为串行队列，<code class="highlighter-rouge">DISPATCH_QUEUE_CONCURRENT</code>为并行队列，该参数可为空（<code class="highlighter-rouge">NULL</code>），当该参数为空时，默认为串行队列，在iOS 4.3或更早版本上，只能指定该参数为空。</p>

    <ul>
      <li>
        <p><code class="highlighter-rouge">DISPATCH_QUEUE_SERIAL</code></p>

        <div class="highlighter-rouge"><pre class="highlight"><code>- (void)test
{
    __block int index = 1;
    dispatch_queue_t queue_serial = dispatch_queue_create("com.tc.serial", DISPATCH_QUEUE_SERIAL);
    NSLog(@"开始运行");
    dispatch_async(queue_serial, ^{
        sleep(3);
        NSLog(@"第1个进入的Block, 第%i个出队列", index++);
    });
    dispatch_async(queue_serial, ^{
        NSLog(@"第2个进入的Block, 第%i个出队列", index++);
    });
    dispatch_async(queue_serial, ^{
        sleep(5);
        NSLog(@"第3个进入的Block, 第%i个出队列", index++);
    });
    dispatch_async(queue_serial, ^{
        sleep(1);
        NSLog(@"第4个进入的Block, 第%i个出队列", index++);
    });
}
</code></pre>
        </div>

        <p>输出（注意时间）：</p>

        <div class="highlighter-rouge"><pre class="highlight"><code>2017-04-28 18:18:47.732 demo[36802:2352075] 开始运行
2017-04-28 18:18:50.736 demo[36802:2352122] 第1个进入的Block, 第1个出队列
2017-04-28 18:18:50.737 demo[36802:2352122] 第2个进入的Block, 第2个出队列
2017-04-28 18:18:55.740 demo[36802:2352122] 第3个进入的Block, 第3个出队列
2017-04-28 18:18:56.744 demo[36802:2352122] 第4个进入的Block, 第4个出队列
</code></pre>
        </div>
      </li>
      <li>
        <p><code class="highlighter-rouge">DISPATCH_QUEUE_CONCURRENT</code></p>

        <div class="highlighter-rouge"><pre class="highlight"><code>- (void)test
{
    __block int index = 1;
    dispatch_queue_t queue_concurrent = dispatch_queue_create("com.tc.concurrent", DISPATCH_QUEUE_CONCURRENT);
    NSLog(@"开始运行");
    dispatch_async(queue_concurrent, ^{
        sleep(3);
        NSLog(@"第1个进入的Block, 第%i个出队列", index++);
    });
    dispatch_async(queue_concurrent, ^{
        NSLog(@"第2个进入的Block, 第%i个出队列", index++);
    });
    dispatch_async(queue_concurrent, ^{
        sleep(5);
        NSLog(@"第3个进入的Block, 第%i个出队列", index++);
    });
    dispatch_async(queue_concurrent, ^{
        sleep(1);
        NSLog(@"第4个进入的Block, 第%i个出队列", index++);
    });
}
</code></pre>
        </div>

        <p>输出（注意时间）：</p>

        <div class="highlighter-rouge"><pre class="highlight"><code>2017-04-28 18:28:25.394 demo[36859:2359335] 开始运行
2017-04-28 18:28:25.394 demo[36859:2359507] 第2个进入的Block, 第1个出队列
2017-04-28 18:28:26.395 demo[36859:2359505] 第4个进入的Block, 第2个出队列
2017-04-28 18:28:28.395 demo[36859:2359522] 第1个进入的Block, 第3个出队列
2017-04-28 18:28:30.395 demo[36859:2359504] 第3个进入的Block, 第4个出队列
</code></pre>
        </div>
      </li>
    </ul>
  </li>
</ul>

<h2 id="dispatch-queue-label-constants">Dispatch Queue Label Constants</h2>

<h3 id="获取队列label">获取队列Label</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>const char * dispatch_queue_get_label(dispatch_queue_t queue);
</code></pre>
</div>

<h4 id="参数-1">参数：</h4>

<ul>
  <li>
    <p><code class="highlighter-rouge">dispatch_queue_t queue</code></p>

    <p>需要获取Label的队列。</p>

    <p>如果需要获取当前队列的Label则使用<code class="highlighter-rouge">DISPATCH_CURRENT_QUEUE_LABEL</code>。</p>

    <div class="highlighter-rouge"><pre class="highlight"><code>- (void)test
{
    dispatch_queue_t queue = dispatch_queue_create("com.tc.queue1", NULL);
    dispatch_sync(queue, ^{
        NSLog(@"%s", dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL));
    });
    NSLog(@"%s", dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL));
    NSLog(@"%s", dispatch_queue_get_label(queue));
}
</code></pre>
    </div>

    <p>输出：</p>

    <div class="highlighter-rouge"><pre class="highlight"><code>2017-05-02 11:16:57.771 demo[38100:2468155] com.tc.queue1
2017-05-02 11:16:57.771 demo[38100:2468155] com.apple.main-thread
2017-05-02 11:16:57.771 demo[38100:2468155] com.tc.queue1
</code></pre>
    </div>
  </li>
</ul>

<h2 id="dispatch_queue_t">dispatch_queue_t</h2>

<h3 id="队列">队列</h3>

<pre><code class="language-dui">typedef NSObject&lt;OS_dispatch_queue&gt; *dispatch_queue_t;
</code></pre>

<p>可见<code class="highlighter-rouge">dispatch_queue_t</code>其实是个对象，也很好的解释了在MRC下为何要手动管理<code class="highlighter-rouge">dispatch_queue_t</code>的内存。</p>

<p>Dispatch队列其实都是FIFO的，在串行队列上毋庸置疑。在并行队列上从表面上看并不符合FIFO的原则，但其实并行队列应该理解为n个并行的队列组合，组合中每个队列也是符合FIFO原则的，GCD帮助程序员管理了如何分配任务给这些组合里的队列。</p>

<h2 id="dispatch_get_main_queue">dispatch_get_main_queue</h2>

<h3 id="获取主队列">获取主队列</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>dispatch_queue_t dispatch_get_main_queue(void);
</code></pre>
</div>

<p>这个函数返回程序的主队列，这个队列在程序一开始时就被创建并与主线程关联，主队列是串行队列。</p>

<p><strong>注意：主线程与主队列并不等同</strong></p>

<p>主队列在在主线程被创建并关联的时机：</p>

<ol>
  <li>调用<code class="highlighter-rouge">dispatch_main()</code></li>
  <li>调用<code class="highlighter-rouge">UIApplicationMain</code>（iOS）或者<code class="highlighter-rouge">NSApplicationMain</code>（macOS）</li>
  <li>在主线程使用<code class="highlighter-rouge">CFRunLoopRef</code></li>
</ol>

<p>大多数情况下我们的App会在<code class="highlighter-rouge">mian()</code>函数里使用第2种方式。</p>

<p>对主队列使用<code class="highlighter-rouge">dispatch_suspend</code>、<code class="highlighter-rouge">dispatch_resume</code>、<code class="highlighter-rouge">dispatch_set_context</code>是无效的。</p>

<h2 id="dispatch_get_global_queue">dispatch_get_global_queue</h2>

<h3 id="获取全局并行队列">获取全局并行队列</h3>

<p>返回系统预定义的全局并行队列。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>dispatch_queue_t dispatch_get_global_queue(long identifier, unsigned long flags);
</code></pre>
</div>

<h4 id="参数-2">参数：</h4>

<ul>
  <li>
    <p><code class="highlighter-rouge">long identifier</code></p>

    <p>全局队列的ID，区别就在于优先级。</p>

    <p>iOS8.0或以上版本：</p>

    <ul>
      <li>QOS_CLASS_USER_INTERACTIVE</li>
      <li>QOS_CLASS_USER_INITIATED</li>
      <li>QOS_CLASS_DEFAULT</li>
      <li>QOS_CLASS_UTILITY</li>
      <li>QOS_CLASS_BACKGROUND</li>
      <li>QOS_CLASS_UNSPECIFIED</li>
    </ul>

    <p>iOS8以下的版本：</p>

    <ul>
      <li>DISPATCH_QUEUE_PRIORITY_HIGH</li>
      <li>DISPATCH_QUEUE_PRIORITY_DEFAULT</li>
      <li>DISPATCH_QUEUE_PRIORITY_LOW</li>
      <li>DISPATCH_QUEUE_PRIORITY_BACKGROUND</li>
    </ul>

    <p>tips：在background队列中，对I/O操作进行了优化，具体可参考<a href="http://www.cocoachina.com/ios/20170105/18525.html" target="_blank">iOS编程中throttle那些事</a>。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">unsigned long flags</code></p>

    <p>为未来的API预留的参数，现在不用管，直接传0。</p>
  </li>
</ul>

<p>对系统预定义队列使用<code class="highlighter-rouge">dispatch_suspend</code>、<code class="highlighter-rouge">dispatch_resume</code>、<code class="highlighter-rouge">dispatch_set_context</code>是无效的。</p>

<h2 id="dispatch_set_target_queue">dispatch_set_target_queue</h2>

<h3 id="给目标对象设置一个队列">给目标对象设置一个队列</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>void dispatch_set_target_queue(dispatch_object_t object, dispatch_queue_t queue);
</code></pre>
</div>

<p>将一个dispatch对象设置一个队列</p>

<h4 id="参数-3">参数：</h4>

<ul>
  <li>
    <p><code class="highlighter-rouge">object</code></p>

    <p>将要设置的对象，不能为空。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">queue</code></p>

    <p><code class="highlighter-rouge">object</code>的新目标队列，设置了目标权限后<code class="highlighter-rouge">queue</code>的引用计数+1会被保留，同时之前设置的<code class="highlighter-rouge">queue</code>会被release。</p>
  </li>
</ul>

<p>这个函数有以下几种用途：</p>

<ul>
  <li>
    <p>将queue作为object参数传入</p>

    <ul>
      <li>
        <p>设置queue的优先级</p>

        <ul>
          <li>
            <p>demo 1</p>

            <div class="highlighter-rouge"><pre class="highlight"><code>- (void)test
{
    dispatch_queue_t tc_queue = dispatch_queue_create("com.tc.queue", DISPATCH_QUEUE_SERIAL);
    dispatch_queue_t default_queue = dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0);
    dispatch_queue_t user_interactive_queue = dispatch_get_global_queue(QOS_CLASS_USER_INTERACTIVE, 0);
    dispatch_set_target_queue(tc_queue, user_interactive_queue);
    dispatch_async(tc_queue, ^{
        double x = MAXFLOAT;
        for(long i = 0; i &lt; 999999999; i++)
        {
            x = x / 1.454;
        }
        NSLog(@"tc_queue");
    });
    dispatch_async(default_queue, ^{
        double x = MAXFLOAT;
        for(long i = 0; i &lt; 999999999; i++)
        {
            x = x / 1.454;
        }
        NSLog(@"default_queue");
    });
    NSLog(@"start");
}
</code></pre>
            </div>

            <p>输出（注意时间）：</p>

            <div class="highlighter-rouge"><pre class="highlight"><code>2017-06-07 16:48:52.391 demo[2494:44948437] start
2017-06-07 16:49:49.425 demo[2494:44948641] tc_queue
2017-06-07 16:49:50.355 demo[2494:44948642] default_queue
</code></pre>
            </div>
          </li>
          <li>
            <p>demo 2</p>

            <div class="highlighter-rouge"><pre class="highlight"><code>- (void)test
{
    dispatch_queue_t tc_queue = dispatch_queue_create("com.tc.queue", DISPATCH_QUEUE_SERIAL);
    dispatch_queue_t default_queue = dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0);
    dispatch_queue_t user_interactive_queue = dispatch_get_global_queue(QOS_CLASS_USER_INTERACTIVE, 0);
    dispatch_set_target_queue(tc_queue, default_queue);
    dispatch_async(tc_queue, ^{
        double x = MAXFLOAT;
        for(long i = 0; i &lt; 999999999; i++)
        {
            x = x / 1.454;
        }
        NSLog(@"tc_queue");
    });
    dispatch_async(user_interactive_queue, ^{
        double x = MAXFLOAT;
        for(long i = 0; i &lt; 999999999; i++)
        {
            x = x / 1.454;
        }
        NSLog(@"user_interactive_queue");
    });
    NSLog(@"start");
}
</code></pre>
            </div>

            <p>输出（注意时间）：</p>

            <div class="highlighter-rouge"><pre class="highlight"><code>2017-06-07 16:52:49.254 demo[2523:45002465] start
2017-06-07 16:53:45.850 demo[2523:45002655] user_interactive_queue
2017-06-07 16:53:46.811 demo[2523:45002661] tc_queue
</code></pre>
            </div>
          </li>
        </ul>
      </li>
      <li>
        <p>将若干串行队列组装成一个串行队列</p>

        <p>一般情况下，向几个串行队列分别提交block，block的执行其实在这几个串行队列中是并行的，没有先后顺序，使用<code class="highlighter-rouge">dispatch_set_target_queue</code>后，可以将串行队列串联起来，可以想象成原来三根吸管吸果汁时，三根吸管同时有果汁到嘴里，现在我们把三根吸管连接起来，嗯大概就是这么个意思，再多想象一点，三根吸管上有很多小洞，离嘴最近习惯上的小洞会更先把果汁送到嘴里。</p>

        <div class="highlighter-rouge"><pre class="highlight"><code>- (void)test
{
    dispatch_queue_t tc_queue = dispatch_queue_create("com.tc.queue", DISPATCH_QUEUE_SERIAL);
    dispatch_queue_t queue_1 = dispatch_queue_create("com.tc.queue.1", DISPATCH_QUEUE_SERIAL);
    dispatch_queue_t queue_2 = dispatch_queue_create("com.tc.queue.2", DISPATCH_QUEUE_SERIAL);
    dispatch_queue_t queue_3 = dispatch_queue_create("com.tc.queue.3", DISPATCH_QUEUE_SERIAL);
    dispatch_set_target_queue(queue_1, tc_queue);
    dispatch_set_target_queue(queue_2, tc_queue);
    dispatch_set_target_queue(queue_3, tc_queue);
    dispatch_async(queue_1, ^{
            
    });
    dispatch_async(queue_3, ^{
            
    });
    dispatch_async(queue_3, ^{
        NSLog(@"1");
    });
    dispatch_async(queue_2, ^{
        NSLog(@"2");
    });
    dispatch_async(queue_1, ^{
        NSLog(@"3");
    });
    dispatch_async(queue_3, ^{
        NSLog(@"4");
    });
    dispatch_async(queue_2, ^{
        NSLog(@"5");
    });
    dispatch_async(queue_1, ^{
        NSLog(@"6");
    });
}
</code></pre>
        </div>

        <p>输出：</p>

        <div class="highlighter-rouge"><pre class="highlight"><code>2017-06-07 17:02:51.065 demo[2631:45141955] 3
2017-06-07 17:02:51.066 demo[2631:45141955] 6
2017-06-07 17:02:51.066 demo[2631:45141955] 1
2017-06-07 17:02:51.066 demo[2631:45141955] 4
2017-06-07 17:02:51.066 demo[2631:45141955] 2
2017-06-07 17:02:51.066 demo[2631:45141955] 5
</code></pre>
        </div>

        <p>需要注意的是，如果使用这种方法，必须注意在同一个target的队列中不要互相同步调用，会死锁。</p>
      </li>
    </ul>
  </li>
  <li>
    <p>将source作为object参数传入</p>

    <p>更换source对应的queue。</p>

    <div class="highlighter-rouge"><pre class="highlight"><code>
</code></pre>
    </div>

    <p>​</p>

    <p>​</p>
  </li>
</ul>

    </article>
  <!-- </article> -->

  <br>
  <br>
  <br>
  <br>
  <p align=right>未经同意，禁止任何形式的转载，作者保留一切权利。如需转载请<a href="mailto:blogtc.git@gmail.com">联系作者</a>。</p>
  <p align=right>blogtc.git@gmail.com</p>
  <hr />
  <br>
  <div style="text-align:center;">
    <p class="supportFont">你的支持是我创作的动力之一</p>
  </div>
  <br>
  <div style="text-align:center;">
    <img width="150px" height="150px" src="/images/support.png"/>
  </div>
  <br>
  <div style="text-align:center;">
    <p>支付宝扫码</p>
  </div>
  <br>
  <br>

</div>

      </div>
    </div>
    
    <footer class="footer">
  <div id="gotop">^</div>
  <br>
	@2017 Blogs by tauCross.
</footer>

    
  </body>

</html>
